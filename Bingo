

#####################################
using System;
using System.Collections.Generic;

public class BusinessDayTimestampGenerator
{
    private static readonly TimeSpan StartTime = new TimeSpan(9, 0, 0); // 9:00 AM
    private static readonly TimeSpan EndTime = new TimeSpan(17, 0, 0);  // 5:00 PM
    private static readonly Random RandomGenerator = new Random();

    private static DateTime currentDate;

    // Initialize the current date to 2 years ago
    static BusinessDayTimestampGenerator()
    {
        currentDate = DateTime.Today.AddYears(-2);
    }

    // Method to generate a list of random timestamps starting from 2 years ago
    public static List<DateTime>? GenerateSequentialBusinessDayTimestamps(int countPerDay)
    {
        List<DateTime> timestamps = new List<DateTime>();

        // Check if we've reached the current date
        if (currentDate > DateTime.Today)
        {
            return null; // No more dates left to generate timestamps
        }

        // Generate the specified number of timestamps for each business day
        for (; currentDate <= DateTime.Today; currentDate = currentDate.AddDays(1))
        {
            if (IsBusinessDay(currentDate))
            {
                // Generate the timestamps for the current business day
                for (int i = 0; i < countPerDay; i++)
                {
                    DateTime randomTime = GetRandomTimeOnDay(currentDate);
                    timestamps.Add(randomTime);
                }
                currentDate = currentDate.AddDays(1); // Move to the next date after generating for the current day
                break; // Stop generating for this call, continue on the next call
            }
        }

        return timestamps;
    }

    // Method to get a random time between 9 AM and 5 PM on a given business day
    private static DateTime GetRandomTimeOnDay(DateTime day)
    {
        // Get a random time between 9:00 AM and 5:00 PM
        int totalSecondsInRange = (int)(EndTime - StartTime).TotalSeconds;
        int randomSeconds = RandomGenerator.Next(totalSecondsInRange);

        TimeSpan randomTime = StartTime.Add(TimeSpan.FromSeconds(randomSeconds));
        return day.Date + randomTime; // Combine the date and time
    }

    // Method to check if a date is a business day (Monday to Friday)
    private static bool IsBusinessDay(DateTime date)
    {
        return date.DayOfWeek != DayOfWeek.Saturday && date.DayOfWeek != DayOfWeek.Sunday;
    }
}


Key Changes:
Static currentDate field: I introduced a static field currentDate to keep track of the current day in the generation process. This field starts at 2 years ago (DateTime.Today.AddYears(-2)).
Return null when out of range: If currentDate is beyond today's date, the method returns null, indicating that there are no more business days left to process.
Generate timestamps day-by-day: In each call to GenerateSequentialBusinessDayTimestamps, the method generates timestamps for the next business day in the sequence. After generating, it updates currentDate to the next day.
Usage Example:

#########################
class Program
{
    static void Main()
    {
        while (true)
        {
            var timestamps = BusinessDayTimestampGenerator.GenerateSequentialBusinessDayTimestamps(500);

            if (timestamps == null)
            {
                Console.WriteLine("No more business days to generate.");
                break;
            }

            // Output a sample of the timestamps
            for (int i = 0; i < Math.Min(timestamps.Count, 5); i++)
            {
                Console.WriteLine(timestamps[i]);
            }

            Console.WriteLine("Generated for a new business day...");
        }
    }
}
Explanation:
Sequential Calls: You can repeatedly call GenerateSequentialBusinessDayTimestamps(500) to generate timestamps day by day until the current date is reached.
Null Check: When the generator runs out of valid dates (i.e., it reaches today's date), it will return null, and the loop will exit.
This solution generates the specified number of timestamps for each business day starting from 2 years ago and stops when it reaches the current date. Let me know if you need further customization!


Here is a simple test class for the BusinessDayTimestampGenerator. This class will help verify that the timestamp generation process works correctly, that timestamps are generated only on business days, and that it returns null when no more business days are available.

#####

using System;
using System.Collections.Generic;
using System.Linq;

public class BusinessDayTimestampGeneratorTest
{
    public static void Main(string[] args)
    {
        TestGenerate500TimestampsPerBusinessDay();
        TestNoMoreDatesAfterCurrentDay();
        TestTimestampsAreWithinBusinessHours();
    }

    // Test to ensure that 500 timestamps are generated for each business day
    public static void TestGenerate500TimestampsPerBusinessDay()
    {
        var timestamps = BusinessDayTimestampGenerator.GenerateSequentialBusinessDayTimestamps(500);

        if (timestamps != null && timestamps.Count == 500)
        {
            Console.WriteLine("TestGenerate500TimestampsPerBusinessDay passed.");
        }
        else
        {
            Console.WriteLine("TestGenerate500TimestampsPerBusinessDay failed.");
        }
    }

    // Test to ensure that no more timestamps are generated after reaching the current date
    public static void TestNoMoreDatesAfterCurrentDay()
    {
        // Simulate calling the generator repeatedly until it returns null
        while (true)
        {
            var timestamps = BusinessDayTimestampGenerator.GenerateSequentialBusinessDayTimestamps(500);
            
            if (timestamps == null)
            {
                Console.WriteLine("TestNoMoreDatesAfterCurrentDay passed.");
                break;
            }
        }
    }

    // Test to ensure that all generated timestamps are within the 9 AM - 5 PM window
    public static void TestTimestampsAreWithinBusinessHours()
    {
        var timestamps = BusinessDayTimestampGenerator.GenerateSequentialBusinessDayTimestamps(500);

        bool areAllWithinBusinessHours = timestamps.All(timestamp =>
            timestamp.TimeOfDay >= new TimeSpan(9, 0, 0) &&
            timestamp.TimeOfDay <= new TimeSpan(17, 0, 0));

        if (areAllWithinBusinessHours)
        {
            Console.WriteLine("TestTimestampsAreWithinBusinessHours passed.");
        }
        else
        {
            Console.WriteLine("TestTimestampsAreWithinBusinessHours failed.");
        }
    }
}
Explanation of Tests:

TestGenerate500TimestampsPerBusinessDay:

This test verifies that the generator produces exactly 500 timestamps for each business day.
If the number of timestamps returned is 500, the test passes; otherwise, it fails.
TestNoMoreDatesAfterCurrentDay:

This test simulates repeatedly calling the generator until it reaches today's date.
Once the generator returns null (indicating no more dates), the test checks whether it correctly identifies that no further dates are available.
TestTimestampsAreWithinBusinessHours:

This test ensures that all generated timestamps are within the business hours of 9 AM to 5 PM.
It verifies that each timestamp's TimeOfDay is within the valid range and reports success if all timestamps are valid.
Running the Tests:
To run the tests, simply execute the BusinessDayTimestampGeneratorTest.Main() method. The test results will be printed to the console.




